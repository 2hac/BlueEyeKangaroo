<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <title>ðŸ§© Unity Web Player</title>
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
    }

    #play-container {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 50;
    }
    .css-5op8vq {
      padding: 12px 24px;
      border-radius: 8px;
      border: none;
      background: #1e88e5;
      color: white;
      font-size: 18px;
      cursor: pointer;
    }

    #unity-container {
      width: 100%;
      height: 100%;
      display: flex;
    }

    #unity-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }

    #unity-loading-bar {
      position: absolute;
      bottom: 10%;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      display: none;
      z-index: 60;
    }
    #unity-progress-bar-empty {
      width: 100%;
      height: 14px;
      background: rgba(255,255,255,0.08);
      border-radius: 8px;
      overflow: hidden;
    }
    #unity-progress-bar-full {
      width: 0%;
      height: 100%;
      background: rgba(0,255,136,0.8);
    }
    #unity-loading-text-wrapper {
      margin-top: 8px;
      text-align: center;
      color: #00ff88;
      font-weight: bold;
    }

    #loading-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #00ff88;
      font-weight: bold;
      text-shadow: 0 0 10px #00ff88;
      z-index: 40;
    }
  </style>
</head>
<body>
  <!-- Play UI -->
  <div id="play-container">
    <button class="css-5op8vq" id="play-button">Play</button>
    <div style="display:none; flex-direction: column; align-items: center; margin-top: 20px; color: red; font-size: 30px;" id="validationtext">Checking saved key...</div>

    <!-- Password input and continue button hidden initially -->
    <div id="password-container" style="display:none; flex-direction: column; align-items: center; margin-top: 20px;">
      <input type="password" id="password-input" placeholder="Input key" style="font-size: 1.2em; padding: 10px; border-radius: 8px; border:none;"/>
      <button class="css-5op8vq" id="continue-button" style="margin-top: 10px;">Continue</button>
    </div>
  </div>

  <!-- Unity container -->
  <div id="unity-container">
    <canvas id="unity-canvas" tabindex="-1"></canvas>
    <div id="unity-loading-bar">
      <div id="unity-progress-bar-empty">
        <div id="unity-progress-bar-full"></div>
      </div>
      <div id="unity-loading-text-wrapper">
        <div id="unity-loading-text">0%</div>
        <div id="unity-loading-icon"></div>
      </div>
    </div>
    <div id="unity-warning"></div>
    <div id="unity-footer" style="position:absolute;bottom:10px;left:10px;color:#888;">
      <div id="unity-webgl-logo"></div>
      <div id="unity-fullscreen-button" style="cursor:pointer;">[Fullscreen]</div>
      <div id="unity-build-title">WebGL Player</div>
      
      <button id="qa-toggle-btn" style="cursor:pointer;">
        QA: OFF
      </button>
    </div>
  </div>

  <!-- extern libs -->
  <!-- extern libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/aes-js/3.1.2/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.4/umd/index.js"></script>



  
  <script>
    const qaBtn = document.getElementById("qa-toggle-btn");

    function updateQaButton() {
      const isOn = localStorage.getItem("QaModeOveride") === "true";
      qaBtn.textContent = `QA: ${isOn ? "ON" : "OFF"}`;
      qaBtn.style.background = isOn ? "#2ecc7144" : "#44444444";
    }

    qaBtn.addEventListener("click", () => {
      const current = localStorage.getItem("QaModeOveride") === "true";
      localStorage.setItem("QaModeOveride", (!current).toString());
      updateQaButton();
    });

    updateQaButton();
  </script>

  <script>
    // UI elements
    const playButton = document.getElementById("play-button");
    const continueButton = document.getElementById("continue-button");
    const playContainer = document.getElementById("play-container");
    const passwordContainer = document.getElementById("password-container");
    const passwordInput = document.getElementById("password-input");
    const unityContainer = document.getElementById("unity-container");
    const loadingBar = document.getElementById("unity-loading-bar");
    const progressBarFull = document.getElementById("unity-progress-bar-full");
    const canvas = document.getElementById("unity-canvas");
    const validationtext = document.getElementById("validationtext");
    const unityloadingtext = document.getElementById("unity-loading-text");

    // Config and defaults
    let ZIP_URL = null;                // <-- will be set from ?f=BASE64
    let PASSWORD = "12345";         // default; overwritten by input/localStorage when used
    let VERSION_NO = null;         // default; overwritten by input/localStorage when used
    const TARGET_FETCH_URL = "parkour"; // partial match used to intercept resources (adjust as needed)

    const streamedZipFiles = new Map();

    // Helper: get query param f (base64)
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    // decode base64 (handles URL-safe base64)
    function base64DecodeToString(b64) {
      if (!b64) return null;
      // handle URL-safe base64
      b64 = b64.replace(/-/g, '+').replace(/_/g, '/');
      // add padding
      while (b64.length % 4 !== 0) b64 += '=';
      try {
        return decodeURIComponent(Array.prototype.map.call(atob(b64), function(c){
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
      } catch (e) {
        // fallback to atob string
        try { return atob(b64); } catch (e2) { return null; }
      }
    }

    // On load: read ZIP URL from ?f=<base64>
    // On load: read ZIP URL and StreamingAssets URL from ?f and ?s
    (function initParams() {
      const fParam = getQueryParam('f');
      const sParam = getQueryParam('s');
      const vParam = getQueryParam('v');

      if (fParam) {
        const decodedF = base64DecodeToString(fParam);
        if (decodedF) {
          ZIP_URL = decodedF;
          console.log("[Init] ZIP URL from ?f:", ZIP_URL);
        } else {
          console.warn("[Init] Could not decode base64 param f");
        }
      } else {
        console.warn("[Init] No ?f param found - ZIP_URL must be set manually");
      }

      if (sParam) {
        const decodedS = base64DecodeToString(sParam);
        if (decodedS) {
          window.STREAMING_ASSETS_URL = decodedS;
          console.log("[Init] StreamingAssets URL from ?s:", STREAMING_ASSETS_URL);
        } else {
          console.warn("[Init] Could not decode base64 param s");
        }
      } else {
        console.log("[Init] No ?s param found - using default 'StreamingAssets'");
        window.STREAMING_ASSETS_URL = "StreamingAssets";
      }

      if (vParam) {
        const decodedS = base64DecodeToString(vParam);
        if (decodedS) {
          VERSION_NO = decodedS;
          console.log("[Init] version URL from ?v:", VERSION_NO);
        } else {
          console.warn("[Init] Could not decode base64 param v");
        }
      } else {
        console.log("[Init] No ?v param found - using default '6'");
        VERSION_NO = "6";
      }
    })();


    // Crypto helpers
    async function deriveKeyAndIV(password) {
      const enc = new TextEncoder();
      const baseKey = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveBits"]
      );

      const derivedBits = await crypto.subtle.deriveBits(
        {
          name: "PBKDF2",
          salt: enc.encode("fixed-salt"),
          iterations: 100000,
          hash: "SHA-256",
        },
        baseKey,
        384 // 48 bytes
      );

      const derived = new Uint8Array(derivedBits);
      const keyBytes = derived.slice(0, 32); // 256-bit key
      const ivBytes = derived.slice(32, 48); // 128-bit IV
      return { key: keyBytes, iv: ivBytes };
    }

    async function importAESKey(rawKey) {
      return crypto.subtle.importKey(
        "raw",
        rawKey,
        { name: "AES-CBC" },
        false,
        ["decrypt"]
      );
    }

    // Wrapper to use with streamFetchDecryptAndUnzip
    async function loadZipStreamed(url, password) {
      console.log("[StreamZip] Starting streamed decrypt+unzip:", url);

      await streamFetchDecryptAndUnzip(url, password, (filename, chunk, final) => {
        if (!streamedZipFiles.has(filename)) {
          streamedZipFiles.set(filename, []);
        }
        streamedZipFiles.get(filename).push(chunk);

        if (final) {
          // Merge chunks into one Uint8Array
          const chunks = streamedZipFiles.get(filename);
          let total = 0;
          for (const c of chunks) total += c.length;

          const full = new Uint8Array(total);
          let offset = 0;
          for (const c of chunks) { full.set(c, offset); offset += c.length; }

          streamedZipFiles.set(filename, full); // replace array-of-chunks with final data
          console.log("[StreamZip] Finished file:", filename, "size:", full.length);
        }
      });

      console.log("[StreamZip] Stream ZIP load complete");
    }


    // ============================================================================
    // getDecryptedStreamedResource(resource)
    // SAME API as getDecryptedResponseForResource()
    // ============================================================================
    async function getDecryptedStreamedResource(resource) {
      const name = filenameFromResource(resource);

      console.log("Files in decrypted ZIP:");
      const streamedZipFiles = Object.keys(streamedZipFiles.files); // lists all files
      console.log(streamedZipFiles);

      if (!streamedZipFiles.has(name)) {
        // try case-insensitive or partial match
        const key = [...streamedZipFiles.keys()].find(k =>
          k.toLowerCase().endsWith(name.toLowerCase()) ||
          k.toLowerCase().includes(name.toLowerCase())
        );
        if (!key) throw new Error("[StreamZip] File not found: " + name);
        return new Response(
          new Blob([streamedZipFiles.get(key)], { type: contentTypeFromFilename(key) })
        );
      }

      const data = streamedZipFiles.get(name);
      return new Response(
        new Blob([data], { type: contentTypeFromFilename(name) })
      );
    }


    // ============================================================================
    // STREAM ZIP OVERRIDE (optional)
    // Forces the system to use the streamed loader instead of JSZip
    // ============================================================================
    let USE_STREAM_ZIP = true;

    // preload ZIP via streaming before Unity loads
    async function preloadStreamZip() {
      if (!ZIP_URL) throw new Error("ZIP_URL not set");
      streamedZipFiles.clear();
      await loadZipStreamed(ZIP_URL, PASSWORD);
    }



    // stream decrypt + unzip using aes-js + fflate
    async function streamFetchDecryptAndUnzip(zipUrl, password, onFile) {
      if (!zipUrl) throw new Error("ZIP URL not set");
      const resp = await fetch(zipUrl);
      if (!resp.ok) throw new Error("Failed to fetch zip: " + resp.status);
      if (!resp.body) throw new Error("ReadableStream not supported in this browser");

      // derive key/iv (same as your deriveKeyAndIV)
      const { key: rawKey, iv: initialIV } = await deriveKeyAndIV(password);

      // convert to plain Uint8Array for aes-js
      const keyBytes = rawKey;                // Uint8Array (32)
      const ivBytes = initialIV;              // Uint8Array (16)

      // create AES-CBC block decryptor (aes-js ModeOfOperation.cbc)
      // aes-js expects arrays of bytes (Uint8Array ok)
      const aesCbc = new aesjs.ModeOfOperation.cbc(keyBytes, ivBytes);

      // fflate streaming unzip: create Unzip instance that will call 'onFile' for each file entry
      // onFile receives (file) where file.ondata(chunk, final) is used to stream file bytes
      const unzip = new fflate.Unzip((entry) => {
        // entry: {name, size, ondata}
        // Provide a default onFile handler if not provided
        const filename = entry.name;
        const chunks = [];
        entry.ondata = (chunk, final) => {
          // chunk is Uint8Array
          // call user callback for stream of file bytes
          if (onFile && typeof onFile === 'function') {
            onFile(filename, chunk, final);
          } else {
            // default collects into an array (careful with huge files)
            chunks.push(chunk.slice());
            if (final) {
              // combine if user didn't provide their own streaming handler
              const full = concatUint8Arrays(chunks);
              console.log("extracted file", filename, "len=", full.length);
            }
          }
        };
      });

      // helper to concat arrays (used only in fallback)
      function concatUint8Arrays(arrs) {
        let total = 0;
        for (const a of arrs) total += a.length;
        const out = new Uint8Array(total);
        let off = 0;
        for (const a of arrs) { out.set(a, off); off += a.length; }
        return out;
      }

      // We'll read from resp.body.getReader() and decrypt in 16-byte blocks.
      const reader = resp.body.getReader();

      // internal buffer for ciphertext bytes we haven't processed yet
      let ctBuf = new Uint8Array(0);

      // For AES-CBC stream decryption with block cipher:
      // - We can decrypt full 16-byte-aligned blocks with aes-js.cbc.decrypt
      // - We must preserve the final block until we know it's the final piece (so we can remove PKCS#7 padding)
      // Strategy:
      // - Keep at least 16 bytes at end of ctBuf unprocessed.
      // - When we have >= 32 bytes, decrypt up to length - 16 bytes (a multiple of 16).
      // - When stream ends, decrypt remaining (multiple of 16 expected) and strip padding.

      // helper to concat two Uint8Arrays
      function concat(a, b) {
        const out = new Uint8Array(a.length + b.length);
        out.set(a, 0); out.set(b, a.length);
        return out;
      }

      let done = false;
      try {
        while (!done) {
          const { value, done: rDone } = await reader.read();
          if (rDone) {
            // stream ended â€” process remaining ciphertext
            done = true;
            // ctBuf may be any length; AES-CBC requires multiple of 16 for decrypt.
            // If not aligned, that's a protocol error â€” but typical enc uses whole file.
            // We'll pad zeroes if required (shouldn't be needed). Prefer to check length mod 16.
            if (ctBuf.length === 0) {
              // nothing left
            } else {
              if (ctBuf.length % 16 !== 0) {
                // if not aligned, try to pad zeros to 16 multiple (only as fallback)
                const padLen = 16 - (ctBuf.length % 16);
                const tmp = new Uint8Array(ctBuf.length + padLen);
                tmp.set(ctBuf);
                // zeros added
                ctBuf = tmp;
              }
              // decrypt ALL remaining blocks
              const decAll = aesCbc.decrypt(ctBuf);
              // remove PKCS#7 padding from final decrypted bytes
              const padding = decAll[decAll.length - 1];
              const endLen = decAll.length - padding;
              const finalPlain = decAll.subarray(0, endLen);
              // feed decrypted bytes to unzip (final chunk)
              unzip.push(finalPlain, true);
            }
            break;
          }

          // append incoming ciphertext chunk
          const chunk = value; // Uint8Array
          ctBuf = concat(ctBuf, chunk);

          // if we have more than 32 bytes, decrypt as many blocks as possible
          // always leave the last 16 bytes in ctBuf unprocessed (so we can chain IV correctly)
          while (ctBuf.length >= 32) {
            // decrypt up to len - 16, and keep final 16 bytes in ctBuf
            const processLen = ctBuf.length - 16; // at least 16, multiple of 1 byte; we must ensure processLen % 16 == 0
            const procBlocks = processLen - (processLen % 16); // round down to multiple of 16
            if (procBlocks === 0) break;
            const toProcess = ctBuf.subarray(0, procBlocks);
            const remaining = ctBuf.subarray(procBlocks);

            // decrypt toProcess (multiple of 16)
            const plain = aesCbc.decrypt(toProcess);
            // push decrypted bytes (not final)
            unzip.push(plain, false);

            // keep remaining (at least 16 bytes)
            ctBuf = new Uint8Array(remaining); // copy
          }
          // loop continues to collect more ciphertext data
        }

        // done reading stream: we already pushed finalPlain above and signalled final=true
        // Now wait for unzip to finish processing entries (fflate works synchronously)
        // nothing else to do
      } catch (err) {
        console.error("stream decrypt/unzip failed", err);
        throw err;
      } finally {
        // explicit cleanup of sensitive material
        // overwrite key material if possible
        if (keyBytes && keyBytes.fill) keyBytes.fill(0);
        if (ivBytes && ivBytes.fill) ivBytes.fill(0);
        ctBuf = null;
      }

      // unzip pushes file entry callbacks which you handle in onFile
      // fflate processes synchronously as data is pushed, so once this function returns,
      // unzip has already invoked entry.ondata for each file chunk.
    }


    // Fetch & decrypt zip (returns JSZip instance)
    async function fetchAndDecryptZipFromUrl(zipUrl, password) {
      if (!zipUrl) throw new Error("ZIP URL not set");

      const resp = await fetch(zipUrl);
      if (!resp.ok) throw new Error("Failed to fetch zip: " + resp.status);

      let encryptedBuffer = await resp.arrayBuffer();
      let view = new Uint8Array(encryptedBuffer);

      // If file begins with PK -> plain ZIP
      if (view[0] === 0x50 && view[1] === 0x4B) {
        console.log("File looks like a plain ZIP, no decryption needed.");

        // free memory
        view = null;
        const plain = encryptedBuffer;
        encryptedBuffer = null;
        await new Promise(r => setTimeout(r, 0));

        return await JSZip.loadAsync(plain);
      }

      // Derive key/iv
      const { key: rawKey, iv } = await deriveKeyAndIV(password);
      const cryptoKey = await importAESKey(rawKey);

      let decryptedBuffer;

      try {
        decryptedBuffer = await crypto.subtle.decrypt(
          { name: "AES-CBC", iv },
          cryptoKey,
          encryptedBuffer
        );
      } catch (err) {
        console.error("Decrypt failed:", err);
        throw err;
      } finally {
        // âœ¨ MEMORY CLEANUP âœ¨
        view = null;
        encryptedBuffer = null;
        await new Promise(r => setTimeout(r, 0)); // allow GC sweep
      }

      return await JSZip.loadAsync(new Uint8Array(decryptedBuffer));
    }


    // utility: content-type from filename ext
    function contentTypeFromFilename(name) {
      const ext = name.split('.').pop().toLowerCase();
      switch (ext) {
        case 'js': return 'application/javascript';
        case 'wasm': return 'application/wasm';
        case 'data': return 'application/octet-stream';
        case 'json': return 'application/json';
        case 'html': return 'text/html';
        case 'png': return 'image/png';
        case 'jpg':
        case 'jpeg': return 'image/jpeg';
        case 'unityweb': return 'application/octet-stream';
        default: return 'application/octet-stream';
      }
    }

    // Extract filename from a URL-ish string
    function filenameFromResource(resource) {
      try {
        const url = new URL(resource, window.location.href);
        return url.pathname.split('/').pop();
      } catch (e) {
        // fallback: just split by /
        const parts = resource.split('/');
        return parts[parts.length - 1] || resource;
      }
    }

    // Cached JSZip instance after successful fetch+decrypt
    let cachedZip = null;

    // Return a Response object containing the requested file from the zip
    async function getDecryptedResponseForResource(resource, password) {
      if (!ZIP_URL) throw new Error("ZIP_URL is not provided (param ?f missing?)");
      // load zip once per session (with provided password)
      if (!cachedZip) {
        cachedZip = await fetchAndDecryptZipFromUrl(ZIP_URL, password);
      }

      // Determine filename requested
      const filename = filenameFromResource(resource);
      console.log("Files in decrypted ZIP:");
      const fileNames = Object.keys(streamZip.files); // lists all files
      console.log(fileNames);
      // If the Unity loader expects different names, you might need to map them here
      const file = cachedZip.file(filename);
      if (!file) {
        // try case-insensitive match or substring
        const maybe = cachedZip.file(Object.keys(cachedZip.files).find(k => k.toLowerCase().endsWith(filename.toLowerCase())));
        if (maybe) {
          const blob = await maybe.async("blob");
          return new Response(blob, { headers: { 'Content-Type': contentTypeFromFilename(maybe.name) } });
        }
        throw new Error(`File ${filename} not found inside zip`);
      }
      const blob = await file.async("blob");
      return new Response(blob, { headers: { 'Content-Type': contentTypeFromFilename(filename) } });
    }

    // Intercept fetch to serve files out of the decrypted zip when matched
    const originalFetch = window.fetch.bind(window);
    window.fetch = async function(resource, init) {
      try {
        // only intercept if resource string contains TARGET_FETCH_URL or if the filename is one of Unity build files
        const resourceStr = (typeof resource === "string") ? resource : (resource && resource.url) ? resource.url : '';
        const shouldIntercept = resourceStr.includes(TARGET_FETCH_URL) ||
                                /Game|Game|Game\.data|Game\.framework\.js|Game\.wasm|\.loader\.js|\.framework\.js|\.wasm|\.data$/i.test(resourceStr);

        if (shouldIntercept && ZIP_URL) {
          console.log("[Interceptor] Serving from decrypted zip:", resourceStr);
          try {
            // return await getDecryptedResponseForResource(resourceStr, PASSWORD);
            if (USE_STREAM_ZIP && streamedZipFiles.size > 0) {
                return await getDecryptedStreamedResource(resourceStr);
            } else {
                return await getDecryptedResponseForResource(resourceStr, PASSWORD);
            }
          } catch (err) {
            console.warn("[Interceptor] Decrypted response failed, falling back to network:", err);
            // fall through to normal fetch
          }
        }
      } catch (e) {
        console.error("Fetch interceptor error:", e);
      }
      return originalFetch(resource, init);
    };

    // Also intercept script src and XHR open for SDK redirections (optional)
    (function redirectSdkExamples(){
      const oldSDK = "https://sdk.crazygames.com/crazygames-sdk-v2.js";
      const newSDK = "https://2hac.github.io/sdk-v2.js";
      const _origOpen = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function(method, url, ...rest) {
        if (typeof url === "string" && url.includes(oldSDK)) url = url.replace(oldSDK, newSDK);
        return _origOpen.call(this, method, url, ...rest);
      };
      const _origSetAttr = Element.prototype.setAttribute;
      Element.prototype.setAttribute = function(name, value) {
        if (name === "src" && typeof value === "string" && value.includes(oldSDK)) value = value.replace(oldSDK, newSDK);
        return _origSetAttr.call(this, name, value);
      };
      // MutationObserver to swap any script nodes added later
      const observer = new MutationObserver((mutations) => {
        for (const m of mutations) {
          for (const node of m.addedNodes) {
            if (node.tagName === "SCRIPT" && node.src && node.src.includes(oldSDK)) {
              node.src = node.src.replace(oldSDK, newSDK);
            }
          }
        }
      });
      observer.observe(document.documentElement, { childList: true, subtree: true });
    })();

    // Helper to create Unity instance by providing blob URLs for loader/framework/data/wasm
    async function startUnity6() {
        if (!ZIP_URL) throw new Error("ZIP_URL not provided. Add ?f=<base64-zip-url> to the URL.");
          

        // hide play UI and show unity container
        playContainer.style.display = "none";
        unityContainer.style.display = "block";
        loadingBar.style.display = "block";

        // wait for stream preload
        if (USE_STREAM_ZIP && streamedZipFiles.size === 0) {
            validationtext.innerText = "Streaming ZIP...";
            await preloadStreamZip();
        }

        // Filenames Unity expects
        const expected = {
            data: "Game.data",
            framework: "Game.framework.js",
            code: "Game.wasm",
            loader: "Game.loader.js"
        };

        // Helper to get blob URLs from streamed files
        async function getStreamedBlobURL(filename) {
            let key = [...streamedZipFiles.keys()].find(k => 
                k.toLowerCase().endsWith(filename.toLowerCase()) || 
                k.toLowerCase().includes(filename.toLowerCase())
            );
            if (!key) throw new Error("File not found in streamed ZIP: " + filename);
            const blob = new Blob([streamedZipFiles.get(key)], { type: contentTypeFromFilename(key) });
            return URL.createObjectURL(blob);
        }

        const dataUrl = await getStreamedBlobURL(expected.data);
        const frameworkUrl = await getStreamedBlobURL(expected.framework);
        const codeUrl = await getStreamedBlobURL(expected.code);
        const loaderUrl = await getStreamedBlobURL(expected.loader);

        const config = {
            dataUrl,
            frameworkUrl,
            codeUrl,
            streamingAssetsUrl: window.STREAMING_ASSETS_URL || "StreamingAssets",
            companyName: "Unity",
            productName: "WebGL Player",
            productVersion: "1.0",
            showBanner: (msg, type) => console.log(type, msg),
        };

        // Load loader script from blob
        const loaderScript = document.createElement("script");
        loaderScript.src = loaderUrl;
        loaderScript.onload = () => {
            try {
                createUnityInstance(canvas, config, (progress) => {
                    const percent = Math.round(progress * 100);
                    progressBarFull.style.width = `${percent}%`;
                    unityloadingtext.innerText = `${percent}%`;
                }).then(unityInstance => {
                    loadingBar.style.display = "none";
                    document.getElementById("unity-fullscreen-button").onclick = () => {
                        try { unityInstance.SetFullscreen(1); } catch(e) {}
                    };
                }).catch(err => {
                    loadingBar.style.display = "none";
                    console.error("Unity instance creation failed:", err);
                });
            } catch (err) {
                loadingBar.style.display = "none";
                console.error("createUnityInstance failed:", err);
            }
        };
        loaderScript.onerror = (e) => console.error("Loader script failed to load:", e);
        document.body.appendChild(loaderScript);
    }


    // helper: produce blob URL from zip by filename
    async function getBlobURLFromZip(zip, filename) {
      // direct file lookup
      let file = zip.file(filename);
      if (!file) {
        // try case-insensitive or contains
        const keys = Object.keys(zip.files);
        const found = keys.find(k => k.toLowerCase().endsWith(filename.toLowerCase()) || k.toLowerCase().includes(filename.toLowerCase()));
        if (found) file = zip.file(found);
      }
      if (!file) throw new Error("Could not find " + filename + " in zip");
      const blob = await file.async("blob");
      return URL.createObjectURL(blob);
    }

    // Play button click flow
    playButton.addEventListener("click", async () => {
        playButton.style.display = "none";
        validationtext.style.display = "flex";

        const savedPassword = localStorage.getItem("S2HACReplayVerifiedKey");
        if (!ZIP_URL) {
            alert("ZIP URL not provided. Add ?f=<base64-zip-url> to the page URL.");
            playButton.style.display = "block";
            validationtext.style.display = "none";
            return;
        }

        PASSWORD = savedPassword || PASSWORD;

        try {
            if (VERSION_NO === "5") await startLegacyUnityV5();
            /* if (USE_STREAM_ZIP) {
                validationtext.innerText = "Streaming ZIP...";
                await preloadStreamZip(); // <-- stream + decrypt + unzip into streamedZipFiles
                console.log("[StreamZip] Ready for Unity fetch interception.");
            } */
            await startUnity6(); // <-- now uses streamed files
            localStorage.setItem("S2HACReplayVerifiedKey", PASSWORD);
            passwordContainer.style.display = "none";
        } catch (err) {
            console.error("Unity start failed:", err);
            validationtext.style.display = "none";
            passwordContainer.style.display = "flex";
            passwordInput.focus();
        }
    });


    // Continue button - user-provided key
    continueButton.addEventListener("click", async () => {
      const inputPassword = passwordInput.value.trim();
      if (!inputPassword) {
        continueButton.innerText = "ENTER KEY";
        continueButton.style.boxShadow = "red 0px 0px 10px";
        continueButton.style.backgroundColor = "rgb(255, 0, 0)";
        passwordInput.focus();
        return;
      }

      // UI feedback
      passwordInput.disabled = true;
      continueButton.disabled = true;
      continueButton.innerText = "Validating...";
      continueButton.style.boxShadow = "blue 0px 0px 10px";
      continueButton.style.backgroundColor = "rgb(0, 0, 255)";

      PASSWORD = inputPassword;

      try {
        try {
          if (VERSION_NO === "5") await startLegacyUnityV5();
          if (USE_STREAM_ZIP) {
              validationtext.innerText = "Streaming ZIP...";
              await preloadStreamZip();
              console.log("[StreamZip] Ready for Unity fetch interception.");
          }
          else await startUnity6();
        } catch (err) {
          alert("Failed: " + err.message);
          console.error(err);
        }
        localStorage.setItem("S2HACReplayVerifiedKey", inputPassword);
        passwordContainer.style.display = "none";
      } catch (err) {
        console.error("Start unity failed with provided key:", err);
        alert("Error: " + (err.message || err));
        playContainer.style.display = "flex";
        passwordContainer.style.display = "flex";
        passwordInput.disabled = false;
        continueButton.disabled = false;
        continueButton.innerText = "KEY WRONG";
        continueButton.style.boxShadow = "red 0px 0px 10px";
        continueButton.style.backgroundColor = "rgb(255, 0, 0)";
        passwordInput.focus();
      }
    });

    // ------------- LEGACY UNITY (v5) LOADER -------------
    async function startLegacyUnityV5() {
      console.log("[Legacy Loader] Starting Unity v5");

      try {
        // Fetch and decrypt the ZIP
        const zip = await fetchAndDecryptZipFromUrl(ZIP_URL, PASSWORD);
        cachedZip = zip;

        
        // hide play UI and show unity container
        playContainer.style.display = "none";
        unityContainer.style.display = "block";
        loadingBar.style.display = "block";

        // Find Unity build files
        const buildJsonFile = Object.keys(zip.files).find(k => k.endsWith(".json"));
        const dataFile = Object.keys(zip.files).find(k => k.endsWith(".data") || k.endsWith(".data.unityweb"));
        const wasmFile = Object.keys(zip.files).find(k => k.endsWith(".wasm.code.unityweb") || k.endsWith(".code.unityweb"));
        const frameworkFile = Object.keys(zip.files).find(k => k.endsWith(".wasm.framework.unityweb") || k.endsWith(".framework.unityweb"));
        const loaderFile = Object.keys(zip.files).find(k => k.toLowerCase().includes("unityloader") && k.endsWith(".js"));

        if (!buildJsonFile || !dataFile || !wasmFile || !frameworkFile || !loaderFile)
          throw new Error("Missing Unity build files inside the ZIP.");

        console.log("[Legacy Loader] Files found:", { buildJsonFile, dataFile, wasmFile, frameworkFile, loaderFile });

        // Load each file as Blobs
        const dataBlob = new Blob([await zip.file(dataFile).async("arraybuffer")], { type: "application/octet-stream" });
        const wasmBlob = new Blob([await zip.file(wasmFile).async("arraybuffer")], { type: "application/wasm" });
        const frameworkBlob = new Blob([await zip.file(frameworkFile).async("arraybuffer")], { type: "application/octet-stream" });
        const loaderBlob = new Blob([await zip.file(loaderFile).async("text")], { type: "application/javascript" });

        // Create Blob URLs
        const dataUrl = URL.createObjectURL(dataBlob);
        const wasmUrl = URL.createObjectURL(wasmBlob);
        const frameworkUrl = URL.createObjectURL(frameworkBlob);
        const loaderUrl = URL.createObjectURL(loaderBlob);

        // Read and patch the build.json
        const originalJson = JSON.parse(await zip.file(buildJsonFile).async("text"));

        const patchedJson = {
          ...originalJson,
          dataUrl: dataUrl,
          wasmCodeUrl: wasmUrl,
          wasmFrameworkUrl: frameworkUrl
        };

        const patchedJsonUrl = URL.createObjectURL(
          new Blob([JSON.stringify(patchedJson)], { type: "application/json" })
        );

        console.log("[Legacy Loader] Patched JSON created:", patchedJson);

        // Prepare UI
        playContainer.style.display = "none";
        unityContainer.style.display = "block";
        loadingBar.style.display = "block";

        // Load UnityLoader.js dynamically
        const script = document.createElement("script");
        script.src = loaderUrl;
        script.onload = () => {
          console.log("[Legacy Loader] UnityLoader script loaded.");

          if (typeof UnityLoader === "undefined") {
            console.error("UnityLoader not found in loader script!");
            return;
          }

          // Instantiate Unity player
          window.gameInstance = UnityLoader.instantiate("unity-container", patchedJsonUrl, {
            onProgress: (inst, progress) => {
              const percent = Math.round(progress * 100);
              progressBarFull.style.width = `${percent}%`;
              // document.getElementById("unity-loading-text").innerText = `${percent}%`;
            }
          });

          console.log("[Legacy Loader] Unity instance started.");
        };

        document.body.appendChild(script);
      } catch (err) {
        console.error("[Legacy Loader] Error:", err);
        alert("Failed to load Unity v5 build.\n\n" + err.message);
      }
    }


    

  </script>
</body>
</html>
