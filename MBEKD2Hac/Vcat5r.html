<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <title>ðŸ§© Unity Web Player</title>
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
    }

    #play-container {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 50;
    }
    .css-5op8vq {
      padding: 12px 24px;
      border-radius: 8px;
      border: none;
      background: #1e88e5;
      color: white;
      font-size: 18px;
      cursor: pointer;
    }

    #unity-container {
      width: 100%;
      height: 100%;
      display: flex;
    }

    #unity-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }

    #unity-loading-bar {
      position: absolute;
      bottom: 10%;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      display: none;
      z-index: 60;
    }
    #unity-progress-bar-empty {
      width: 100%;
      height: 14px;
      background: rgba(255,255,255,0.08);
      border-radius: 8px;
      overflow: hidden;
    }
    #unity-progress-bar-full {
      width: 0%;
      height: 100%;
      background: rgba(0,255,136,0.8);
    }
    #unity-loading-text-wrapper {
      margin-top: 8px;
      text-align: center;
      color: #00ff88;
      font-weight: bold;
    }

    #loading-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #00ff88;
      font-weight: bold;
      text-shadow: 0 0 10px #00ff88;
      z-index: 40;
    }
  </style>
</head>
<body>
  <!-- Play UI -->
  <div id="play-container">
    <button class="css-5op8vq" id="play-button">Play</button>
    <div style="display:none; flex-direction: column; align-items: center; margin-top: 20px; color: red; font-size: 30px;" id="validationtext">Checking saved key...</div>

    <!-- Password input and continue button hidden initially -->
    <div id="password-container" style="display:none; flex-direction: column; align-items: center; margin-top: 20px;">
      <input type="password" id="password-input" placeholder="Input key" style="font-size: 1.2em; padding: 10px; border-radius: 8px; border:none;"/>
      <button class="css-5op8vq" id="continue-button" style="margin-top: 10px;">Continue</button>
    </div>
  </div>

  <!-- Unity container -->
  <div id="unity-container">
    <canvas id="unity-canvas" tabindex="-1"></canvas>
    <div id="unity-loading-bar">
      <div id="unity-progress-bar-empty">
        <div id="unity-progress-bar-full"></div>
      </div>
      <div id="unity-loading-text-wrapper">
        <div id="unity-loading-text">0%</div>
        <div id="unity-loading-icon"></div>
      </div>
    </div>
    <div id="unity-warning"></div>
    <div id="unity-footer" style="position:absolute;bottom:10px;left:10px;color:#888;">
      <div id="unity-webgl-logo"></div>
      <div id="unity-fullscreen-button" style="cursor:pointer;">[Fullscreen]</div>
      <div id="unity-build-title">WebGL Player</div>
      
      <button id="qa-toggle-btn" style="cursor:pointer;">
        QA: OFF
      </button>
    </div>
  </div>

  <!-- extern libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  
  <script>
    const qaBtn = document.getElementById("qa-toggle-btn");

    function updateQaButton() {
      const isOn = localStorage.getItem("QaModeOveride") === "true";
      qaBtn.textContent = `QA: ${isOn ? "ON" : "OFF"}`;
      qaBtn.style.background = isOn ? "#2ecc7144" : "#44444444";
    }

    qaBtn.addEventListener("click", () => {
      const current = localStorage.getItem("QaModeOveride") === "true";
      localStorage.setItem("QaModeOveride", (!current).toString());
      updateQaButton();
    });

    updateQaButton();
  </script>

  <script>
    // UI elements
    const playButton = document.getElementById("play-button");
    const continueButton = document.getElementById("continue-button");
    const playContainer = document.getElementById("play-container");
    const passwordContainer = document.getElementById("password-container");
    const passwordInput = document.getElementById("password-input");
    const unityContainer = document.getElementById("unity-container");
    const loadingBar = document.getElementById("unity-loading-bar");
    const progressBarFull = document.getElementById("unity-progress-bar-full");
    const canvas = document.getElementById("unity-canvas");
    const validationtext = document.getElementById("validationtext");
    const unityloadingtext = document.getElementById("unity-loading-text");

    // Config and defaults
    let ZIP_URL = null;                // <-- will be set from ?f=BASE64
    let PASSWORD = "12345";         // default; overwritten by input/localStorage when used
    let VERSION_NO = null;         // default; overwritten by input/localStorage when used
    let VERSIOND_NO = null;         // default; overwritten by input/localStorage when used
    const TARGET_FETCH_URL = "parkour"; // partial match used to intercept resources (adjust as needed)
    const DB_NAME = "UnityDeCache";
    const DB_VERSION = 1;
    let INTERCEPTION_ENABLED = false;


    // STORE NAME NOW COMES FROM ?d=
    let STORE_NAME = null;


    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);

        req.onupgradeneeded = (event) => {
          const db = event.target.result;

          if (!db.objectStoreNames.contains(STORE_NAME)) {
            console.log("[DB] Creating store:", STORE_NAME);
            db.createObjectStore(STORE_NAME);
          }
        };

        req.onsuccess = (evt) => {
          let db = evt.target.result;

          // If store missing â†’ MUST delete DB and recreate it
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            console.warn("[DB] Store missing, recreating DB:", STORE_NAME);

            db.close();
            const del = indexedDB.deleteDatabase(DB_NAME);

            del.onsuccess = () => {
              const req2 = indexedDB.open(DB_NAME, DB_VERSION);

              req2.onupgradeneeded = (e2) => {
                const db2 = e2.target.result;
                db2.createObjectStore(STORE_NAME);
              };

              req2.onsuccess = (e2) => resolve(e2.target.result);
              req2.onerror = () => reject(req2.error);
            };

            del.onerror = () => reject(del.error);
            return;
          }

          resolve(db);
        };

        req.onerror = () => reject(req.error);
      });
    }

    

    async function storeExistsAndHasFile(name) {
        try {
            const blob = await loadFileFromDB(name);
            return !!blob;
        } catch {
            return false;
        }
    }


    async function saveFileToDB(filename, blob) {
      const db = await openDB();
      return new Promise((res, rej) => {
        const tx = db.transaction(STORE_NAME, "readwrite");
        tx.objectStore(STORE_NAME).put(blob, filename);
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }

    async function loadFileFromDB(filename) {
      const db = await openDB();
      return new Promise((res, rej) => {
        const tx = db.transaction(STORE_NAME, "readonly");
        const req = tx.objectStore(STORE_NAME).get(filename);
        req.onsuccess = () => res(req.result || null);
        req.onerror = () => rej(req.error);
      });
    }

    async function hasFile(filename) {
      const file = await loadFileFromDB(filename);
      return file !== null;
    }

    // Helper: get query param f (base64)
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    // decode base64 (handles URL-safe base64)
    function base64DecodeToString(b64) {
      if (!b64) return null;
      // handle URL-safe base64
      b64 = b64.replace(/-/g, '+').replace(/_/g, '/');
      // add padding
      while (b64.length % 4 !== 0) b64 += '=';
      try {
        return decodeURIComponent(Array.prototype.map.call(atob(b64), function(c){
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
      } catch (e) {
        // fallback to atob string
        try { return atob(b64); } catch (e2) { return null; }
      }
    }

    function getFileFromDB(key) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onerror = () => reject("IndexedDB open error");

            request.onsuccess = event => {
                const db = event.target.result;

                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    resolve(null);
                    return;
                }

                const tx = db.transaction(STORE_NAME, "readonly");
                const store = tx.objectStore(STORE_NAME);
                const getReq = store.get(key);

                getReq.onerror = () => reject("Failed to get file");
                getReq.onsuccess = () => resolve(getReq.result || null);

                tx.oncomplete = () => db.close();
            };
        });
    }

    // On load: read ZIP URL from ?f=<base64>
    // On load: read ZIP URL and StreamingAssets URL from ?f and ?s
    (function initParams() {
      const fParam = getQueryParam('f');
      const sParam = getQueryParam('s');
      const vParam = getQueryParam('v');
      const dParam = getQueryParam('d');

      if (fParam) {
        const decodedF = base64DecodeToString(fParam);
        if (decodedF) {
          ZIP_URL = decodedF;
          console.log("[Init] ZIP URL from ?f:", ZIP_URL);
        } else {
          console.warn("[Init] Could not decode base64 param f");
        }
      } else {
        console.warn("[Init] No ?f param found - ZIP_URL must be set manually");
      }

      if (sParam) {
        const decodedS = base64DecodeToString(sParam);
        if (decodedS) {
          window.STREAMING_ASSETS_URL = decodedS;
          console.log("[Init] StreamingAssets URL from ?s:", STREAMING_ASSETS_URL);
        } else {
          console.warn("[Init] Could not decode base64 param s");
        }
      } else {
        console.log("[Init] No ?s param found - using default 'StreamingAssets'");
        window.STREAMING_ASSETS_URL = "StreamingAssets";
      }

      if (vParam) {
          const decodedV = base64DecodeToString(vParam);
          if (decodedV) {
              VERSION_NO = decodedV;
              console.log("[Init] version URL from ?v:", VERSION_NO);
          } else {
              console.warn("[Init] Could not decode base64 param v");
          }
      } else {
          console.log("[Init] No ?v param found - using default '6'");
      }

      if (dParam) {
          const decodedD = base64DecodeToString(dParam);
          if (decodedD) {
              VERSIOND_NO = decodedD;
              STORE_NAME = "ver_" + VERSIOND_NO;
              console.log("[Init] version URL from ?d:", VERSIOND_NO);
              console.log("[Init] Using object store:", STORE_NAME);
          } else {
              console.warn("[Init] Could not decode base64 param d");
          }
      } else {
          console.log("[Init] No ?d param found");
      }

    })();


    // Crypto helpers
    async function deriveKeyAndIV(password) {
      const enc = new TextEncoder();
      const baseKey = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveBits"]
      );

      const derivedBits = await crypto.subtle.deriveBits(
        {
          name: "PBKDF2",
          salt: enc.encode("fixed-salt"),
          iterations: 100000,
          hash: "SHA-256",
        },
        baseKey,
        384 // 48 bytes
      );

      const derived = new Uint8Array(derivedBits);
      const keyBytes = derived.slice(0, 32); // 256-bit key
      const ivBytes = derived.slice(32, 48); // 128-bit IV
      return { key: keyBytes, iv: ivBytes };
    }

    async function importAESKey(rawKey) {
      return crypto.subtle.importKey(
        "raw",
        rawKey,
        { name: "AES-CBC" },
        false,
        ["decrypt"]
      );
    }

    // Fetch & decrypt zip (returns JSZip instance)
    async function fetchAndDecryptZipFromUrl(zipUrl, password) {
      if (!zipUrl) throw new Error("ZIP URL not set");
      const resp = await fetch(zipUrl);
      if (!resp.ok) throw new Error("Failed to fetch zip: " + resp.status);
      const encryptedBuffer = await resp.arrayBuffer();
      const view = new Uint8Array(encryptedBuffer);

      // If the file already begins with PK (0x50 0x4B), treat as plain zip
      if (view[0] === 0x50 && view[1] === 0x4B) {
        console.log("File looks like a plain ZIP, no decryption needed.");
        return await JSZip.loadAsync(encryptedBuffer);
      }

      // otherwise derive key/iv and decrypt the whole buffer using AES-CBC
      const { key: rawKey, iv } = await deriveKeyAndIV(password);
      const cryptoKey = await importAESKey(rawKey);
      // note: crypto.subtle.decrypt expects ArrayBuffer
      try {
        const decryptedBuffer = await crypto.subtle.decrypt({ name: "AES-CBC", iv }, cryptoKey, encryptedBuffer);
        return await JSZip.loadAsync(new Uint8Array(decryptedBuffer));
      } catch (err) {
        console.error("Decrypt failed:", err);
        throw err;
      }
    }

    // utility: content-type from filename ext
    function contentTypeFromFilename(name) {
      const ext = name.split('.').pop().toLowerCase();
      switch (ext) {
        case 'js': return 'application/javascript';
        case 'wasm': return 'application/wasm';
        case 'data': return 'application/octet-stream';
        case 'json': return 'application/json';
        case 'html': return 'text/html';
        case 'png': return 'image/png';
        case 'jpg':
        case 'jpeg': return 'image/jpeg';
        case 'unityweb': return 'application/octet-stream';
        default: return 'application/octet-stream';
      }
    }

    // Extract filename from a URL-ish string
    function filenameFromResource(resource) {
      try {
        const url = new URL(resource, window.location.href);
        return url.pathname.split('/').pop();
      } catch (e) {
        // fallback: just split by /
        const parts = resource.split('/');
        return parts[parts.length - 1] || resource;
      }
    }

    // Cached JSZip instance after successful fetch+decrypt
    let cachedZip = null;

    // Return a Response object containing the requested file from the zip
    async function getDecryptedResponseForResource(resource, password) {
      const filename = filenameFromResource(resource);

      // 1. LOOK IN LOCAL DB FIRST
      const cachedBlob = await loadFileFromDB(filename);
      if (cachedBlob) {
        console.log("[DB] Loaded from IndexedDB:", filename);
        return new Response(cachedBlob, {
          headers: { "Content-Type": contentTypeFromFilename(filename) }
        });
      }

      // 2. Not cached â†’ decrypt ZIP (once)
      if (!cachedZip) cachedZip = await fetchAndDecryptZipFromUrl(ZIP_URL, password);

      const file = cachedZip.file(filename);
      if (!file) throw new Error(`File ${filename} not found in zip`);

      const blob = await file.async("blob");

      // 3. STORE IN LOCAL DB FOR NEXT TIME
      await saveFileToDB(filename, blob);
      console.log("[DB] Saved to IndexedDB:", filename);

      return new Response(blob, {
        headers: { "Content-Type": contentTypeFromFilename(filename) }
      });
    }

    // Intercept fetch to serve files out of the decrypted zip when matched
    const originalFetch = window.fetch.bind(window);
    window.fetch = async function(resource, init) {
      try {
        if (!INTERCEPTION_ENABLED) {
          return originalFetch(resource, init);
        }

        const resourceStr = typeof resource === "string"
            ? resource
            : resource?.url || '';

        const shouldIntercept =
          resourceStr.includes(TARGET_FETCH_URL) ||
          /Game\.data|Game\.framework\.js|Game\.wasm|Game\.loader\.js|\.unityweb$/i.test(resourceStr);

        if (shouldIntercept && ZIP_URL) {
          return await getDecryptedResponseForResource(resourceStr, PASSWORD);
        }
      } catch (e) {
        console.error("Fetch interceptor error:", e);
      }

      return originalFetch(resource, init);
    };


    // Helper to create Unity instance by providing blob URLs for loader/framework/data/wasm
    async function startUnity6() {
        if (!ZIP_URL) throw new Error("ZIP_URL not provided.");

        const expected = {
            data: "Game.data",
            framework: "Game.framework.js",
            code: "Game.wasm",
            loader: "Game.loader.js",
        };

        let zip = null;

        // 1. Try reading everything from IndexedDB first
        const stored = {};
        let allFound = true;

        for (const key in expected) {
            const fn = expected[key];
            stored[key] = await loadFileFromDB(fn);
            if (!stored[key]) allFound = false;
        }

        // 2. If ALL files were in DB â†’ no ZIP needed
        if (allFound) {
            console.log("[CACHE] Loaded all files from DB.");
        } else {
            console.log("[CACHE] DB missing files â†’ loading ZIP...");

            zip = await fetchAndDecryptZipFromUrl(ZIP_URL, PASSWORD);
            console.log("ZIP FILES:", Object.keys(zip.files));

            for (const key in expected) {
                const fn = expected[key];

                const fileObj = zip.file(fn);
                if (!fileObj) throw new Error("ZIP missing file: " + fn);

                const blob = await fileObj.async("blob");
                stored[key] = blob;

                await saveFileToDB(fn, blob);
                console.log("[DB] Saved:", fn);
            }
        }

        // 3. Build blob URLs from stored data
        const dataUrl = URL.createObjectURL(stored.data);
        const frameworkUrl = URL.createObjectURL(stored.framework);
        const codeUrl = URL.createObjectURL(stored.code);
        const loaderUrl = URL.createObjectURL(stored.loader);

        playContainer.style.display = "none";
        unityContainer.style.display = "block";
        loadingBar.style.display = "block";

        const config = {
            dataUrl,
            frameworkUrl,
            codeUrl,
            streamingAssetsUrl: window.STREAMING_ASSETS_URL || "StreamingAssets",
            companyName: "Unity",
            productName: "WebGL Player",
            productVersion: "1.0",
            showBanner: (msg, type) => console.log(type, msg),
        };

        const loaderScript = document.createElement("script");
        loaderScript.src = loaderUrl;

        loaderScript.onload = () => {
            createUnityInstance(canvas, config, (progress) => {
                progressBarFull.style.width = `${Math.round(progress * 100)}%`;
            });
        };

        loaderScript.onerror = () => alert("Loader script failed to load.");
        document.body.appendChild(loaderScript);
    }


    // helper: produce blob URL from zip by filename
    async function getBlobURLFromZip(zip, filename) {

      // 1. Try DB
      const cached = await loadFileFromDB(filename);
      if (cached) {
        console.log("[DB] Blob URL from DB:", filename);
        return URL.createObjectURL(cached);
      }

      // 2. Try ZIP
      let file = zip.file(filename);
      if (!file) {
        const keys = Object.keys(zip.files);
        const match = keys.find(k => k.toLowerCase().includes(filename.toLowerCase()));
        if (match) file = zip.file(match);
      }
      if (!file) throw new Error("Missing file " + filename);

      const blob = await file.async("blob");

      // 3. SAVE TO DB
      await saveFileToDB(filename, blob);
      console.log("[DB] Saved blob to DB:", filename);

      return URL.createObjectURL(blob);
    }


    // Play button click flow
    playButton.addEventListener("click", async () => {
      playButton.style.display = "none";
      validationtext.style.display = "flex";

      const savedPassword = localStorage.getItem("S2HACReplayVerifiedKey");
      if (!ZIP_URL) {
        alert("ZIP URL not provided. Add ?f=<base64-zip-url> to the page URL.");
        playButton.style.display = "block";
        validationtext.style.display = "none";
        return;
      }

      if (savedPassword) {
        try {
          PASSWORD = savedPassword;
          try {
            if (VERSION_NO === "5") await startLegacyUnityV5();
            else await startUnity6();
          } catch (err) {
            alert("Failed: " + err.message);
            console.error(err);
          }
        } catch (e) {
          console.error("Error using the saved password:", e);
          validationtext.style.display = "none";
          passwordContainer.style.display = "flex";
          passwordInput.focus();
        }
      } else {
        validationtext.style.display = "none";
        passwordContainer.style.display = "flex";
        passwordInput.focus();
      }
    });

    // Continue button - user-provided key
    continueButton.addEventListener("click", async () => {
      const inputPassword = passwordInput.value.trim();
      if (!inputPassword) {
        continueButton.innerText = "ENTER KEY";
        continueButton.style.boxShadow = "red 0px 0px 10px";
        continueButton.style.backgroundColor = "rgb(255, 0, 0)";
        passwordInput.focus();
        return;
      }

      // UI feedback
      passwordInput.disabled = true;
      continueButton.disabled = true;
      continueButton.innerText = "Validating...";
      continueButton.style.boxShadow = "blue 0px 0px 10px";
      continueButton.style.backgroundColor = "rgb(0, 0, 255)";

      PASSWORD = inputPassword;

      try {
        try {
          if (VERSION_NO === "5") await startLegacyUnityV5();
          else await startUnity6();
        } catch (err) {
          alert("Failed: " + err.message);
          console.error(err);
        }
        localStorage.setItem("S2HACReplayVerifiedKey", inputPassword);
        passwordContainer.style.display = "none";
      } catch (err) {
        console.error("Start unity failed with provided key:", err);
        alert("Error: " + (err.message || err));
        playContainer.style.display = "flex";
        passwordContainer.style.display = "flex";
        passwordInput.disabled = false;
        continueButton.disabled = false;
        continueButton.innerText = "KEY WRONG";
        continueButton.style.boxShadow = "red 0px 0px 10px";
        continueButton.style.backgroundColor = "rgb(255, 0, 0)";
        passwordInput.focus();
      }
    });

    // ------------- LEGACY UNITY (v5) LOADER -------------
    async function startLegacyUnityV5() {
      console.log("[Legacy Loader] Starting Unity v5");

      try {
        // Fetch and decrypt the ZIP
        const zip = await fetchAndDecryptZipFromUrl(ZIP_URL, PASSWORD);
        cachedZip = zip;

        
        // hide play UI and show unity container
        playContainer.style.display = "none";
        unityContainer.style.display = "block";
        loadingBar.style.display = "block";

        // Find Unity build files
        const buildJsonFile = Object.keys(zip.files).find(k => k.endsWith(".json"));
        const dataFile = Object.keys(zip.files).find(k => k.endsWith(".data") || k.endsWith(".data.unityweb"));
        const wasmFile = Object.keys(zip.files).find(k => k.endsWith(".wasm.code.unityweb") || k.endsWith(".code.unityweb"));
        const frameworkFile = Object.keys(zip.files).find(k => k.endsWith(".wasm.framework.unityweb") || k.endsWith(".framework.unityweb"));
        const loaderFile = Object.keys(zip.files).find(k => k.toLowerCase().includes("unityloader") && k.endsWith(".js"));

        if (!buildJsonFile || !dataFile || !wasmFile || !frameworkFile || !loaderFile)
          throw new Error("Missing Unity build files inside the ZIP.");

        console.log("[Legacy Loader] Files found:", { buildJsonFile, dataFile, wasmFile, frameworkFile, loaderFile });

        // Load each file as Blobs
        const dataBlob = new Blob([await zip.file(dataFile).async("arraybuffer")], { type: "application/octet-stream" });
        const wasmBlob = new Blob([await zip.file(wasmFile).async("arraybuffer")], { type: "application/wasm" });
        const frameworkBlob = new Blob([await zip.file(frameworkFile).async("arraybuffer")], { type: "application/octet-stream" });
        const loaderBlob = new Blob([await zip.file(loaderFile).async("text")], { type: "application/javascript" });

        // Create Blob URLs
        const dataUrl = URL.createObjectURL(dataBlob);
        const wasmUrl = URL.createObjectURL(wasmBlob);
        const frameworkUrl = URL.createObjectURL(frameworkBlob);
        const loaderUrl = URL.createObjectURL(loaderBlob);

        // Read and patch the build.json
        const originalJson = JSON.parse(await zip.file(buildJsonFile).async("text"));

        const patchedJson = {
          ...originalJson,
          dataUrl: dataUrl,
          wasmCodeUrl: wasmUrl,
          wasmFrameworkUrl: frameworkUrl
        };

        const patchedJsonUrl = URL.createObjectURL(
          new Blob([JSON.stringify(patchedJson)], { type: "application/json" })
        );

        console.log("[Legacy Loader] Patched JSON created:", patchedJson);

        // Prepare UI
        playContainer.style.display = "none";
        unityContainer.style.display = "block";
        loadingBar.style.display = "block";

        // Load UnityLoader.js dynamically
        const script = document.createElement("script");
        script.src = loaderUrl;
        script.onload = () => {
          console.log("[Legacy Loader] UnityLoader script loaded.");

          if (typeof UnityLoader === "undefined") {
            console.error("UnityLoader not found in loader script!");
            return;
          }

          // Instantiate Unity player
          window.gameInstance = UnityLoader.instantiate("unity-container", patchedJsonUrl, {
            onProgress: (inst, progress) => {
              const percent = Math.round(progress * 100);
              progressBarFull.style.width = `${percent}%`;
            }
          });

          console.log("[Legacy Loader] Unity instance started.");
        };

        document.body.appendChild(script);
      } catch (err) {
        console.error("[Legacy Loader] Error:", err);
        alert("Failed to load Unity v5 build.\n\n" + err.message);
      }
    }


    

  </script>
</body>
</html>
