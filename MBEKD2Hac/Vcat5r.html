<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <title>ðŸ§© Unity Web Player</title>
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
    }

    #play-container {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 50;
    }
    .css-5op8vq {
      padding: 12px 24px;
      border-radius: 8px;
      border: none;
      background: #1e88e5;
      color: white;
      font-size: 18px;
      cursor: pointer;
    }

    #unity-container {
      width: 100%;
      height: 100%;
      display: flex;
    }

    #unity-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
    }

    #unity-loading-bar {
      position: absolute;
      bottom: 10%;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      display: none;
      z-index: 60;
    }
    #unity-progress-bar-empty {
      width: 100%;
      height: 14px;
      background: rgba(255,255,255,0.08);
      border-radius: 8px;
      overflow: hidden;
    }
    #unity-progress-bar-full {
      width: 0%;
      height: 100%;
      background: rgba(0,255,136,0.8);
    }
    #unity-loading-text-wrapper {
      margin-top: 8px;
      text-align: center;
      color: #00ff88;
      font-weight: bold;
    }

    #loading-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #00ff88;
      font-weight: bold;
      text-shadow: 0 0 10px #00ff88;
      z-index: 40;
    }
  </style>
</head>
<body>
  <!-- Play UI -->
  <div id="play-container">
    <button class="css-5op8vq" id="play-button">Play</button>
    <div style="display:none; flex-direction: column; align-items: center; margin-top: 20px; color: red; font-size: 30px;" id="validationtext">Checking saved key...</div>

    <!-- Password input and continue button hidden initially -->
    <div id="password-container" style="display:none; flex-direction: column; align-items: center; margin-top: 20px;">
      <input type="password" id="password-input" placeholder="Input key" style="font-size: 1.2em; padding: 10px; border-radius: 8px; border:none;"/>
      <button class="css-5op8vq" id="continue-button" style="margin-top: 10px;">Continue</button>
    </div>
  </div>

  <!-- Unity container -->
  <div id="unity-container">
    <canvas id="unity-canvas" tabindex="-1"></canvas>
    <div id="unity-loading-bar">
      <div id="unity-progress-bar-empty">
        <div id="unity-progress-bar-full"></div>
      </div>
      <div id="unity-loading-text-wrapper">
        <div id="unity-loading-text">0%</div>
        <div id="unity-loading-icon"></div>
      </div>
    </div>
    <div id="unity-warning"></div>
    <div id="unity-footer" style="position:absolute;bottom:10px;left:10px;color:#888;">
      <div id="unity-webgl-logo"></div>
      <div id="unity-fullscreen-button" style="cursor:pointer;">[Fullscreen]</div>
      <div id="unity-build-title">WebGL Player</div>
      
      <button id="qa-toggle-btn" style="cursor:pointer;">
        QA: OFF
      </button>
    </div>
  </div>

  <!-- extern libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  
  <script>
    const qaBtn = document.getElementById("qa-toggle-btn");

    function updateQaButton() {
      const isOn = localStorage.getItem("QaModeOveride") === "true";
      qaBtn.textContent = `QA: ${isOn ? "ON" : "OFF"}`;
      qaBtn.style.background = isOn ? "#2ecc7144" : "#44444444";
    }

    qaBtn.addEventListener("click", () => {
      const current = localStorage.getItem("QaModeOveride") === "true";
      localStorage.setItem("QaModeOveride", (!current).toString());
      updateQaButton();
    });

    updateQaButton();
  </script>

  <script>
    // UI elements
    const playButton = document.getElementById("play-button");
    const continueButton = document.getElementById("continue-button");
    const playContainer = document.getElementById("play-container");
    const passwordContainer = document.getElementById("password-container");
    const passwordInput = document.getElementById("password-input");
    const unityContainer = document.getElementById("unity-container");
    const loadingBar = document.getElementById("unity-loading-bar");
    const progressBarFull = document.getElementById("unity-progress-bar-full");
    const canvas = document.getElementById("unity-canvas");
    const validationtext = document.getElementById("validationtext");
    const unityloadingtext = document.getElementById("unity-loading-text");

    // Config and defaults
    let ZIP_URL = null;                // <-- will be set from ?f=BASE64
    let PASSWORD = "12345";         // default; overwritten by input/localStorage when used
    let VERSION_NO = null;         // default; overwritten by input/localStorage when used
    const TARGET_FETCH_URL = "parkour"; // partial match used to intercept resources (adjust as needed)

    // Helper: get query param f (base64)
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    // decode base64 (handles URL-safe base64)
    function base64DecodeToString(b64) {
      if (!b64) return null;
      // handle URL-safe base64
      b64 = b64.replace(/-/g, '+').replace(/_/g, '/');
      // add padding
      while (b64.length % 4 !== 0) b64 += '=';
      try {
        return decodeURIComponent(Array.prototype.map.call(atob(b64), function(c){
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
      } catch (e) {
        // fallback to atob string
        try { return atob(b64); } catch (e2) { return null; }
      }
    }

    // On load: read ZIP URL from ?f=<base64>
    // On load: read ZIP URL and StreamingAssets URL from ?f and ?s
    (function initParams() {
      const fParam = getQueryParam('f');
      const sParam = getQueryParam('s');
      const vParam = getQueryParam('v');

      if (fParam) {
        const decodedF = base64DecodeToString(fParam);
        if (decodedF) {
          ZIP_URL = decodedF;
          console.log("[Init] ZIP URL from ?f:", ZIP_URL);
        } else {
          console.warn("[Init] Could not decode base64 param f");
        }
      } else {
        console.warn("[Init] No ?f param found - ZIP_URL must be set manually");
      }

      if (sParam) {
        const decodedS = base64DecodeToString(sParam);
        if (decodedS) {
          window.STREAMING_ASSETS_URL = decodedS;
          console.log("[Init] StreamingAssets URL from ?s:", STREAMING_ASSETS_URL);
        } else {
          console.warn("[Init] Could not decode base64 param s");
        }
      } else {
        console.log("[Init] No ?s param found - using default 'StreamingAssets'");
        window.STREAMING_ASSETS_URL = "StreamingAssets";
      }

      if (vParam) {
        const decodedS = base64DecodeToString(vParam);
        if (decodedS) {
          VERSION_NO = decodedS;
          console.log("[Init] version URL from ?v:", VERSION_NO);
        } else {
          console.warn("[Init] Could not decode base64 param v");
        }
      } else {
        console.log("[Init] No ?v param found - using default '6'");
        VERSION_NO = "6";
      }
    })();


    // Crypto helpers
    async function deriveKeyAndIV(password) {
      const enc = new TextEncoder();
      const baseKey = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveBits"]
      );

      const derivedBits = await crypto.subtle.deriveBits(
        {
          name: "PBKDF2",
          salt: enc.encode("fixed-salt"),
          iterations: 100000,
          hash: "SHA-256",
        },
        baseKey,
        384 // 48 bytes
      );

      const derived = new Uint8Array(derivedBits);
      const keyBytes = derived.slice(0, 32); // 256-bit key
      const ivBytes = derived.slice(32, 48); // 128-bit IV
      return { key: keyBytes, iv: ivBytes };
    }

    async function importAESKey(rawKey) {
      return crypto.subtle.importKey(
        "raw",
        rawKey,
        { name: "AES-CBC" },
        false,
        ["decrypt"]
      );
    }

    // Fetch & decrypt zip (returns JSZip instance)
    async function fetchAndDecryptZipFromUrl(zipUrl, password) {
      if (!zipUrl) throw new Error("ZIP URL not set");
      const resp = await fetch(zipUrl);
      if (!resp.ok) throw new Error("Failed to fetch zip: " + resp.status);
      const encryptedBuffer = await resp.arrayBuffer();
      const view = new Uint8Array(encryptedBuffer);

      // If the file already begins with PK (0x50 0x4B), treat as plain zip
      if (view[0] === 0x50 && view[1] === 0x4B) {
        console.log("File looks like a plain ZIP, no decryption needed.");
        return await JSZip.loadAsync(encryptedBuffer);
      }

      // otherwise derive key/iv and decrypt the whole buffer using AES-CBC
      const { key: rawKey, iv } = await deriveKeyAndIV(password);
      const cryptoKey = await importAESKey(rawKey);
      // note: crypto.subtle.decrypt expects ArrayBuffer
      try {
        const decryptedBuffer = await crypto.subtle.decrypt({ name: "AES-CBC", iv }, cryptoKey, encryptedBuffer);
        return await JSZip.loadAsync(new Uint8Array(decryptedBuffer));
      } catch (err) {
        console.error("Decrypt failed:", err);
        throw err;
      }
    }

    // utility: content-type from filename ext
    function contentTypeFromFilename(name) {
      const ext = name.split('.').pop().toLowerCase();
      switch (ext) {
        case 'js': return 'application/javascript';
        case 'wasm': return 'application/wasm';
        case 'data': return 'application/octet-stream';
        case 'json': return 'application/json';
        case 'html': return 'text/html';
        case 'png': return 'image/png';
        case 'jpg':
        case 'jpeg': return 'image/jpeg';
        case 'unityweb': return 'application/octet-stream';
        default: return 'application/octet-stream';
      }
    }

    // Extract filename from a URL-ish string
    function filenameFromResource(resource) {
      try {
        const url = new URL(resource, window.location.href);
        return url.pathname.split('/').pop();
      } catch (e) {
        // fallback: just split by /
        const parts = resource.split('/');
        return parts[parts.length - 1] || resource;
      }
    }

    // Cached JSZip instance after successful fetch+decrypt
    let cachedZip = null;

    // Return a Response object containing the requested file from the zip
    async function getDecryptedResponseForResource(resource, password) {
      if (!ZIP_URL) throw new Error("ZIP_URL is not provided (param ?f missing?)");
      // load zip once per session (with provided password)
      if (!cachedZip) {
        cachedZip = await fetchAndDecryptZipFromUrl(ZIP_URL, password);
      }

      // Determine filename requested
      const filename = filenameFromResource(resource);

      // If the Unity loader expects different names, you might need to map them here
      const file = cachedZip.file(filename);
      if (!file) {
        // try case-insensitive match or substring
        const maybe = cachedZip.file(Object.keys(cachedZip.files).find(k => k.toLowerCase().endsWith(filename.toLowerCase())));
        if (maybe) {
          const blob = await maybe.async("blob");
          return new Response(blob, { headers: { 'Content-Type': contentTypeFromFilename(maybe.name) } });
        }
        throw new Error(`File ${filename} not found inside zip`);
      }
      const blob = await file.async("blob");
      return new Response(blob, { headers: { 'Content-Type': contentTypeFromFilename(filename) } });
    }

    // Intercept fetch to serve files out of the decrypted zip when matched
    const originalFetch = window.fetch.bind(window);
    window.fetch = async function(resource, init) {
      try {
        // only intercept if resource string contains TARGET_FETCH_URL or if the filename is one of Unity build files
        const resourceStr = (typeof resource === "string") ? resource : (resource && resource.url) ? resource.url : '';
        const shouldIntercept = resourceStr.includes(TARGET_FETCH_URL) ||
                                /Game|Game|Game\.data|Game\.framework\.js|Game\.wasm|\.loader\.js|\.framework\.js|\.wasm|\.data$/i.test(resourceStr);

        if (shouldIntercept && ZIP_URL) {
          console.log("[Interceptor] Serving from decrypted zip:", resourceStr);
          try {
            return await getDecryptedResponseForResource(resourceStr, PASSWORD);
          } catch (err) {
            console.warn("[Interceptor] Decrypted response failed, falling back to network:", err);
            // fall through to normal fetch
          }
        }
      } catch (e) {
        console.error("Fetch interceptor error:", e);
      }
      return originalFetch(resource, init);
    };

    // Also intercept script src and XHR open for SDK redirections (optional)
    (function redirectSdkExamples(){
      const oldSDK = "https://sdk.crazygames.com/crazygames-sdk-v2.js";
      const newSDK = "https://2hac.github.io/sdk-v2.js";
      const _origOpen = XMLHttpRequest.prototype.open;
      XMLHttpRequest.prototype.open = function(method, url, ...rest) {
        if (typeof url === "string" && url.includes(oldSDK)) url = url.replace(oldSDK, newSDK);
        return _origOpen.call(this, method, url, ...rest);
      };
      const _origSetAttr = Element.prototype.setAttribute;
      Element.prototype.setAttribute = function(name, value) {
        if (name === "src" && typeof value === "string" && value.includes(oldSDK)) value = value.replace(oldSDK, newSDK);
        return _origSetAttr.call(this, name, value);
      };
      // MutationObserver to swap any script nodes added later
      const observer = new MutationObserver((mutations) => {
        for (const m of mutations) {
          for (const node of m.addedNodes) {
            if (node.tagName === "SCRIPT" && node.src && node.src.includes(oldSDK)) {
              node.src = node.src.replace(oldSDK, newSDK);
            }
          }
        }
      });
      observer.observe(document.documentElement, { childList: true, subtree: true });
    })();

    // Helper to create Unity instance by providing blob URLs for loader/framework/data/wasm
    async function startUnity6() {
      if (!ZIP_URL) throw new Error("ZIP_URL not provided. Add ?f=<base64-encoded-zip-url> to the URL.");
      // fetch & decrypt zip once, will populate cachedZip
      const zip = await fetchAndDecryptZipFromUrl(ZIP_URL, PASSWORD);
      cachedZip = zip; // cache it

      // hide play UI and show unity container
      playContainer.style.display = "none";
      unityContainer.style.display = "block";
      loadingBar.style.display = "block";

      // filenames that we expect inside zip - adjust names if they vary
       // helper: find file by base name or .br
      async function findFile(zip, baseName) {
        const names = Object.keys(zip.files);
        const match = names.find(
          n =>
            n.endsWith(baseName) ||
            n.endsWith(baseName + ".br") ||
            n.includes(baseName + ".br") ||
            n.includes(baseName)
        );
        if (!match) throw new Error(`Could not find ${baseName} in zip`);
        return getBlobURLFromZip(zip, match);
      }

      // resolve all needed URLs (supporting both normal and .br)
      const dataUrl = await findFile(zip, "Game.data");
      const frameworkUrl = await findFile(zip, "Game.framework.js");
      const codeUrl = await findFile(zip, "Game.wasm");
      const loaderUrl = await findFile(zip, "Game.loader.js");

      const config = {
        dataUrl,
        frameworkUrl,
        codeUrl,
        streamingAssetsUrl: window.STREAMING_ASSETS_URL || "StreamingAssets",
        companyName: "Unity",
        productName: "WebGL Player",
        productVersion: "1.0",
        showBanner: (msg, type) => console.log(type, msg),
      };

      // load loader script from blob and start unity
      const loaderScript = document.createElement("script");
      loaderScript.src = loaderUrl;
      loaderScript.onload = () => {
        // createUnityInstance provided by loader script
        try {
          createUnityInstance(canvas, config, (progress) => {
            const percent = Math.round(progress * 100);
            progressBarFull.style.width = `${percent}%`;
            document.getElementById("unity-loading-text").innerText = `${percent}%`;
          }).then((unityInstance) => {
            loadingBar.style.display = "none";
            document.getElementById("unity-fullscreen-button").onclick = () => {
              try { unityInstance.SetFullscreen(1); } catch(e) { console.warn("Fullscreen call failed", e); }
            };
          }).catch((err) => {
            loadingBar.style.display = "none";
            alert("Unity error: " + err);
          });
        } catch (err) {
          loadingBar.style.display = "none";
          console.error("createUnityInstance failed to run:", err);
        }
      };
      loaderScript.onerror = (e) => {
        console.error("Loader script failed to load:", e);
        alert("Loader script failed to load. Check console.");
      };
      document.body.appendChild(loaderScript);
    }

    // helper: produce blob URL from zip by filename
    async function getBlobURLFromZip(zip, filename) {
      // direct file lookup
      let file = zip.file(filename);
      if (!file) {
        // try case-insensitive or contains
        const keys = Object.keys(zip.files);
        const found = keys.find(k => k.toLowerCase().endsWith(filename.toLowerCase()) || k.toLowerCase().includes(filename.toLowerCase()));
        if (found) file = zip.file(found);
      }
      if (!file) throw new Error("Could not find " + filename + " in zip");
      const blob = await file.async("blob");
      return URL.createObjectURL(blob);
    }

    // Play button click flow
    playButton.addEventListener("click", async () => {
      playButton.style.display = "none";
      validationtext.style.display = "flex";

      const savedPassword = localStorage.getItem("S2HACReplayVerifiedKey");
      if (!ZIP_URL) {
        alert("ZIP URL not provided. Add ?f=<base64-zip-url> to the page URL.");
        playButton.style.display = "block";
        validationtext.style.display = "none";
        return;
      }

      if (savedPassword) {
        try {
          PASSWORD = savedPassword;
          try {
            if (VERSION_NO === "5") await startLegacyUnityV5();
            else await startUnity6();
          } catch (err) {
            alert("Failed: " + err.message);
            console.error(err);
          }
        } catch (e) {
          console.error("Error using the saved password:", e);
          validationtext.style.display = "none";
          passwordContainer.style.display = "flex";
          passwordInput.focus();
        }
      } else {
        validationtext.style.display = "none";
        passwordContainer.style.display = "flex";
        passwordInput.focus();
      }
    });

    // Continue button - user-provided key
    continueButton.addEventListener("click", async () => {
      const inputPassword = passwordInput.value.trim();
      if (!inputPassword) {
        continueButton.innerText = "ENTER KEY";
        continueButton.style.boxShadow = "red 0px 0px 10px";
        continueButton.style.backgroundColor = "rgb(255, 0, 0)";
        passwordInput.focus();
        return;
      }

      // UI feedback
      passwordInput.disabled = true;
      continueButton.disabled = true;
      continueButton.innerText = "Validating...";
      continueButton.style.boxShadow = "blue 0px 0px 10px";
      continueButton.style.backgroundColor = "rgb(0, 0, 255)";

      PASSWORD = inputPassword;

      try {
        try {
          if (VERSION_NO === "5") await startLegacyUnityV5();
          else await startUnity6();
        } catch (err) {
          alert("Failed: " + err.message);
          console.error(err);
        }
        localStorage.setItem("S2HACReplayVerifiedKey", inputPassword);
        passwordContainer.style.display = "none";
      } catch (err) {
        console.error("Start unity failed with provided key:", err);
        alert("Error: " + (err.message || err));
        playContainer.style.display = "flex";
        passwordContainer.style.display = "flex";
        passwordInput.disabled = false;
        continueButton.disabled = false;
        continueButton.innerText = "KEY WRONG";
        continueButton.style.boxShadow = "red 0px 0px 10px";
        continueButton.style.backgroundColor = "rgb(255, 0, 0)";
        passwordInput.focus();
      }
    });

    // ------------- LEGACY UNITY (v5) LOADER -------------
    async function startLegacyUnityV5() {
      console.log("[Legacy Loader] Starting Unity v5");

      try {
        // Fetch and decrypt the ZIP
        const zip = await fetchAndDecryptZipFromUrl(ZIP_URL, PASSWORD);
        cachedZip = zip;

        
        // hide play UI and show unity container
        playContainer.style.display = "none";
        unityContainer.style.display = "block";
        loadingBar.style.display = "block";

        // Find Unity build files
        const buildJsonFile = Object.keys(zip.files).find(k => k.endsWith(".json"));
        const dataFile = Object.keys(zip.files).find(k => k.endsWith(".data") || k.endsWith(".data.unityweb"));
        const wasmFile = Object.keys(zip.files).find(k => k.endsWith(".wasm.code.unityweb") || k.endsWith(".code.unityweb"));
        const frameworkFile = Object.keys(zip.files).find(k => k.endsWith(".wasm.framework.unityweb") || k.endsWith(".framework.unityweb"));
        const loaderFile = Object.keys(zip.files).find(k => k.toLowerCase().includes("unityloader") && k.endsWith(".js"));

        if (!buildJsonFile || !dataFile || !wasmFile || !frameworkFile || !loaderFile)
          throw new Error("Missing Unity build files inside the ZIP.");

        console.log("[Legacy Loader] Files found:", { buildJsonFile, dataFile, wasmFile, frameworkFile, loaderFile });

        // Load each file as Blobs
        const dataBlob = new Blob([await zip.file(dataFile).async("arraybuffer")], { type: "application/octet-stream" });
        const wasmBlob = new Blob([await zip.file(wasmFile).async("arraybuffer")], { type: "application/wasm" });
        const frameworkBlob = new Blob([await zip.file(frameworkFile).async("arraybuffer")], { type: "application/octet-stream" });
        const loaderBlob = new Blob([await zip.file(loaderFile).async("text")], { type: "application/javascript" });

        // Create Blob URLs
        const dataUrl = URL.createObjectURL(dataBlob);
        const wasmUrl = URL.createObjectURL(wasmBlob);
        const frameworkUrl = URL.createObjectURL(frameworkBlob);
        const loaderUrl = URL.createObjectURL(loaderBlob);

        // Read and patch the build.json
        const originalJson = JSON.parse(await zip.file(buildJsonFile).async("text"));

        const patchedJson = {
          ...originalJson,
          dataUrl: dataUrl,
          wasmCodeUrl: wasmUrl,
          wasmFrameworkUrl: frameworkUrl
        };

        const patchedJsonUrl = URL.createObjectURL(
          new Blob([JSON.stringify(patchedJson)], { type: "application/json" })
        );

        console.log("[Legacy Loader] Patched JSON created:", patchedJson);

        // Prepare UI
        playContainer.style.display = "none";
        unityContainer.style.display = "block";
        loadingBar.style.display = "block";

        // Load UnityLoader.js dynamically
        const script = document.createElement("script");
        script.src = loaderUrl;
        script.onload = () => {
          console.log("[Legacy Loader] UnityLoader script loaded.");

          if (typeof UnityLoader === "undefined") {
            console.error("UnityLoader not found in loader script!");
            return;
          }

          // Instantiate Unity player
          window.gameInstance = UnityLoader.instantiate("unity-container", patchedJsonUrl, {
            onProgress: (inst, progress) => {
              const percent = Math.round(progress * 100);
              progressBarFull.style.width = `${percent}%`;
              // document.getElementById("unity-loading-text").innerText = `${percent}%`;
            }
          });

          console.log("[Legacy Loader] Unity instance started.");
        };

        document.body.appendChild(script);
      } catch (err) {
        console.error("[Legacy Loader] Error:", err);
        alert("Failed to load Unity v5 build.\n\n" + err.message);
      }
    }


    

  </script>
</body>
</html>
